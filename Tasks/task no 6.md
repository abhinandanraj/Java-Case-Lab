## Задание 6 - Многопоточное программирование

 Описание задания
 
 Создайте многопоточное приложение на Java и использованием Thread и Executor Framework, которое
 не только симулирует работу банка с кассами, но и добавляет дополнительные слои сложности, такие
 как валютный обмен и переводы между клиентами.
 
 Компоненты
 
 1. Клиент: объект с уникальным ID, суммой денег, и валютой.
 2. Касса: обработчик транзакций, каждая касса работает в отдельном потоке.
 3. Банк: хранит информацию о всех клиентах и кассах, а также курсах валют.
    
 Требования
 
 1. Добавить функциональность для обмена валют: exchangeCurrency(int clientId, String
 fromCurrency, String toCurrency, double amount).
 2. Реализовать переводы между клиентами: transferFunds(int senderId, int receiverId,
 double amount).
 3. Использовать ScheduledThreadPoolExecutor для автоматического обновления курсов валют.
 4. Реализовать очередь транзакций, которая обрабатывается асинхронно.
 5. Применить паттерн Observer для логгирования.
    
 Дополнительные детали к домашнему заданию
 
 1. Использование ScheduledThreadPoolExecutor для автоматического обновления курсов валют
 Цель этого требования — симулировать реальный мир, где курсы валют постоянно меняются. Создайте
 задачу, которая автоматически обновляет курсы валют в вашем Bank объекте.

 Программа должна иметь примерно следующую структуру:

    class Bank {
        private final Map<String, Double> exchangeRates = new ConcurrentHashMap<>(); 
        public Bank() { 
            ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1); 
            executor.scheduleAtFixedRate( 
                () -> { 
                          /* Здесь обновляются курсы валют */ 
                }, 0, 1, TimeUnit.SECOND); 
         }
          ... 
    } 

2. Реализация очереди транзакций, которая обрабатывается асинхронно

Идея здесь в том, чтобы операции (переводы, пополнения, снятия и т.д.) не обрабатывались мгновенно,
а добавлялись в очередь. Эта очередь затем асинхронно обрабатывается отдельными потоками
кассами).

    class Bank { 
        Queue<AbstractList> queue = new LinkedBlockingQueue<>(); 
         public Bank() { 
            /* Запускаем потоки-кассы для обработки очереди */ 
        } 
    } 
    
    class Cachier extends Thread { 
        @Override 
        public void run() { 
            while (active) { 
                Transaction transaction = Bank.getTransactionQueue().take(); 
                /* Обработка транзакции */ 
             } 
        }   
    }

3. Применение паттерна Observer для логгирования
Паттерн Observer позволяет оповестить зарегистрированные объекты (наблюдатели) о событиях,
происходящих в системе. В данной задаче, его можно использовать для логгирования всех операций и
событий, таких как переводы, пополнения баланса и изменения курса валют.

Сначала создайте интерфейс Observer:

     interface Observer { 
         void update(String message); 
     } 
     
Затем добавьте его реализацию, которая будет записывать логи:

    class Logger extends Observer { 
        @Override 
        public void update(String message) { 
            // Здесь ваш код для логгирования, например: 
            System.out.printf("Log: %s", message); 
        } 
     } 
     
В классе Bank, добавьте методы для регистрации и оповещения наблюдателей:

    class Bank { 
        private List<Observer> observers = new ArrayList<>(); 
        void addObserver(Observer observer) { 
            observers.add(observer); 
        } 
        void notifyObservers(String message) { 
            for (Observer o: observers) { 
                o.update(message); 
            } 
        } 
    } 
    
Теперь, каждый раз при изменении курса валюты или выполнении транзакции, вызывайте
notifyObservers с соответствующим сообщением.
 
Примерная структура кода

    class Client{
        public Client(int id, double balance, String currency) { /* ... */ } 
    } 
    
    class Cashier extends Thread { 
        public Cashier(int id, Bank bank) { /* ... */ } 
        void deposit(int clientId, double amount) { /* ... */ } 
        void withdraw(int clientId, double amount) { /* ... */ } 
        void exchangeCurrency(int clientId, String fromCurrency, String toCurrency, 
    double amount) { /* ... */ } 
        void transferFunds(int senderId, int receiverId, double amount) { /* ... */ } 
    } 
    
    class Bank { 
        ConcurrentHashMap<Int, Client> clients = /* ... */ 
        List<Cashier> cashiers = /* ... */ 
        ConcurrentHashMap<String, Double> exchangeRates = /* ... */   
        /* Другие функции и механизмы */ 
    }

 
 Концепции
 
 В данном домашнем задании, многопоточность будет активно использоваться в нескольких местах:
 
 1. Кассы (cashiers): Каждая касса будет работать в своём потоке, обрабатывая транзакции из общей
 очереди. Потоки нужно будет синхронизировать таким образом, чтобы не возникло проблем с
 конкурентным доступом к данным клиентов.
 2. Автоматическое обновление курсов валют: Используя ScheduledThreadPoolExecutor, вы можете
 создать отдельный поток, который будет регулярно обновлять курсы валют. Здесь ключевой
 момент в том, чтобы корректно обновлять информацию, доступ к которой могут иметь другие
 потоки.
 3. Асинхронная очередь транзакций: Элементы этой очереди будут обрабатываться асинхронно
 кассами. Важно удостовериться, что операции с очередью потокобезопасны.
 4. Логгирование с использованием паттерна Observer: В этом случае, многопоточность может
 косвенно затрагивать логгирование, так как обновления могут приходить из разных потоков.
 Нужно обеспечить, чтобы метод update в Observer был потокобезопасным.

 Все эти многопоточные операции требуют аккуратной синхронизации и возможно использование
 примитивов синхронизации для обеспечения корректного доступа к ресурсам

 Что ожидается
 
 1. Код должен быть написан с учетом принципов ООП и SOLID.
 2. Аккуратное логгирование всех операций и ошибок.
 3. Предоставить документацию и инструкцию по запуску.

